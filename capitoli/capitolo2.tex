\chapter{GLL Parsing}
\section{Introduzione}
Nel capitolo precedente abbiamo discusso i concetti e il funzionamento del parsing su grammatiche LL(1). In questo capitolo discuteremo di un estenzione di questo parsing, chiamato \textbf{Parsing LL Generalizzato (GLL)} e vedremo come questo parser supera i limiti che hanno i parser LL(1). Mostreremo i concetti base di questo parsing e del suo funzionamento
\section{Stack e descrittori elementari}
In questo paragrafo discuteremo del funzionamento base del GLL Parsing. Data la seguente grammatica:
\begin{align}\label{grammaticaNLL1}
	S & \to E \notag \\
	E & \to X \mid aXY \notag \\
	X & \to \epsilon \notag \\
	Y & \to bEa 
\end{align}
Un parser a discesa ricorsiva \cite{pubblicazione: scott} è composto dalle seguenti funzioni: $p_S$(), $p_E$(), $p_X$(), $p_Y$(), la funzione principale \textit{main}() e la funzione per segnalare gli errori \textit{error}(). Ogni funzione contiene codice per ogni alternativa, $\alpha$, e verificano il simbolo corrente della stringa in input appartiene a FIRST($\alpha$) o al FOLLOW($\alpha$). La stringa in input viene rappresentata come un array globale \textit{I} di lunghezza \textit{m}+1, e che \textit{I}[\textit{m}]=$\$$, che segnala la fine della stringa. L'implementazione del parser viene rappresentata di seguito.\\
main()$\{$ \textit{i} = 0 \par
\hspace{1cm}\textbf{if}(\textit{I}[\textit{i}] $\in$ $\{$\textit{a,$\$$}$\}$)$\{$ $p_S$() $\}$ \textbf{else} \textit{error}();\par
\hspace{1cm}\textbf{if}(\textit{I}[\textit{i}] = $\$$)$\{$ report success $\}$ \textbf{else} \textit{error}()\\ 
$\}$\\
\vspace{0.5cm}
$p_S$() $\{$ \textbf{if}(\textit{I}[\textit{i}] $\in$ $\{$\textit{a,$\$$}$\}$)$\{$ $p_E$(); $\}$ \textbf{else} $\{$ \textit{error}(); $\}$ $\}$ \\
\vspace{0.2cm}
$p_E$() $\{$ \textbf{if}(\textit{I}[\textit{i}] $\in$ $\{$\textit{a,$\$$}$\}$)$\{$ $p_X$(); $\}$ \par
\hspace{0.8cm}\textbf{else} $\{$ \textbf{if}(\textit{I}[\textit{i}] = \textit{a})$\{$ \textit{i}=\textit{i}+1; $p_X$(); $p_Y$(); $\}$
$\}$\par 
\hspace{0.7cm} \textbf{else} $\{$ \textit{error}() $\}$ $\}$ \\
\vspace{0.2cm}
$p_X$() $\{$ $\}$\\
\vspace{0.2cm}
$p_Y$() $\{$ \textbf{if}(\textit{I}[\textit{i}] = \textit{b})$\{$ \textit{i}=\textit{i}+1; $p_E$(); \textbf{if}(\textit{I}[\textit{i}] = \textit{a})$\{$ \textit{i}=\textit{i}+1; $\}$ \textbf{else} $\{$ \textit{error}(); $\}$ $\}$ \par	
\hspace{0.8cm}\textbf{else} $\{$ \textit{error}(); $\}$ $\}$\par
\vspace{0.5cm}Questa è la tabella di parsing della grammatica \ref{grammaticaNLL1}.
\begin{table}[hbpb]
	\centering
	\label{tabellaparsingNLL1}
	\begin{tabular}{ccccc} 
		\toprule
		%\multirow{2}*{\textbf{Non Terminale}} & %\multicolumn{4}{c}{\textbf{Simbolo d'ingresso}} \\ 
		%\cmidrule(lr){2-4}
		& a & b & $\$$ \\ 
		\midrule
		\textit{Y} 	& & \textit{Y} $\to$ \textit{bEa} &     \\ 
		\textit{S} & \textit{S} $\to$ \textit{E}  &  & \textit{S} $\to$ \textit{E}   \\ 
		\textit{X} & \textit{X} $\to$ $\epsilon$ & \textit{X} $\to$ $\epsilon$ &  \textit{X} $\to$ $\epsilon$ \\ 
		\textit{E} 	& \textit{E} $\to$ \textit{X} $\mid$ \textit{aXY} & &  \textit{E} $\to$ \textit{X}  \\
		\bottomrule
	\end{tabular}
	\caption{\textit{Tabella di parsing della grammatica }\ref{grammaticaNLL1}}
\end{table} \par
Da quello che si può notare dalla tabella \ref{grammaticaNLL1} questa grammatica non è LL(1) in quanto è presente un conflitto e di conseguenza l'algoritmo implementato non funziona correttamente. Affinchè l'algoritmo funzioni correttamente è necessario aggiungere il non-determinismo. Per fare ciò dobbiamo convertire le chiamate a funzioni con operazioni di \textbf{push} di  uno stack e utilizzo di \textbf{goto}. Poi partizioniamo in varie parti i corpi delle funzioni il cui non-terminale è non LL(1) ed attribuiamo un etichetta ad ogni partizione. In pratica potremo avere diverse etichette per partizioni per ogni conflitto di un non-terminale, per esempio, in questo caso abbiamo più partizioni per \textit{E}. Per registrare le possibili scelte che il parser può fare per sostituire un non-terminale utilizziamo dei \textbf{descrittori} all'interno dell'algoritmo a discesa ricorsiva e sostituiamo il punto in cui termina l'algoritmo con l'esecuzione di un descrittore successivo. Le funzioni d'errore vengono sostituite con l'esecuzione di descrittori successivi. Il nuovo punto di termine sarà quando non esistono più descrittori da eseguire.
\section{Strutture dati fondamentali}
uyuy
\subsection{Graph structured stacks}
yuyuy
\subsection{Insiemi U e P}
yuyuyu
\subsection{Shared packed parse forests}
yuyuy
\section{Costruzione del GSS}
joijo
\section{Definizione GLL Parsing}
nklnlknkn
\subsection{Funzioni Fondamentali}
kiuiu
\subsection{Gestione degli item}
opopokp
\subsection{Gestione dei simboli non-terminali}
lòlòkbj
\section{Costruzione del GLL Parser}
eeeededed