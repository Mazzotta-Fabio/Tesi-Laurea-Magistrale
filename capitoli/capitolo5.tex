\chapter{Implementazione del GLL Posizionale}
\section{Introduzione}
Nel capitolo seguente vedremo come è si implementa il GLL parsing sule grammatiche posizionali. Descriveremo come sono gestiti gli operatori spaziali e come viene letto l'input in corrispondenza dei simboli terminali. Per il resto la gestione dei non terminali e degli item delle varie produzioni sono state gestite allo stesso modo che vale per il GLL parsing lineare.
\section{GLL Parsing su espressioni aritmetiche}
In questo paragrafo discutiamo di come è stato implementato e gestito il GLL Parsing sulla grammmatica posizionale delle espressioni regolari. La grammatica è la seguente:
\begin{align}\label{gramPos1}
E & \to T > + > E \mid  T \notag \\
T & \to F < hbar < T \mid F \notag \\
F & \to ( > E > ) \mid id 
\end{align}
Il simbolo \textbf{>}e \textbf{<} sono operatori spaziali che indicano rispettivamente di spostarsi in orizzontale e in verticale per leggere l'input.
\subsection{Gestione dell'input}
La gestione dell'input è stato definito nella classe \textbf{InputDataset} presente nel file \textbf{\textit{InputDataset.java}}.
\lstinputlisting{C:/Users/fabio/Documents/GitHub/In.java}
La classe \textbf{InputDataset} ha come variabili d'istanza (linee 8-11) un ArrayList \textit{buf}, che viene utilizzato per identificare univocamente i vari token e una matrice \textit{picture} che viene utilizzata per rappresentare l'immagine di rappresentazione dell'input. Alle linee 18-34 è stato definito il metodo \textbf{loadData()} che viene utilizzato per caricare l'input presente in un file nella matrice \textit{picture} e nell'array \textit{buf}. L'input viene salvato anche in array in maniera tale da poter associare un identificativo ad ogni token. Nella matrice i token sono rappresentati attraverso gli identificativi che sono stati associati dall'array \textit{buf}. Alle linee 37-39 il metodo \textbf{getToken()} restituisce il token in base all'identificativo ricevuto in input. Il metodo \textbf{setTokenFound()} (linee 42-57) viene utilizzato per inserire un token che è stato letto all'interno dell'array dei token visti. Infine abbiamo il metodo \textbf{getNextToken()} linee(75-98) che viene utilizzato per ottenere il token successivo. Questo metodo legge la matrice finchè non trova l'ultimo simbolo letto, una volta trovato seleziona le regole per leggere il token successivo (linee 77-84). Se il simbolo è < allora il token successivo deve essere letto sulla riga successiva rispetto all'ultimo token visto, altrimenti se il simbolo è > il token successivo viene letto sulla colonna di destra rispetto all'ultimo token visto. Nel caso in cui l'ultimo simbolo letto si trova sull'ultima riga o colonna della tabella il token successivo verrà scelto leggendo tutta la matrice. Dopodichè si legge la matrice partendo dagli indici calcolati dagli operatori spaziali (linee 86-92) e si restituisce il primo token non visto. Per stabilire se il token è stato visto o no si usa il metodo \textbf{isViewed()} (linee 60-67) che restituisce \textit{false} se il token è stato visto o \textit{true} se il token non è stato visto.
\subsection{La classe GLLParsingPosizionale}
Per implementare il GLL Parsing sulle espressioni aritmetiche è stata creata la classe GLLParsingPosizionale. Gli insiemi che il parsing utilizza sono sempre gli stessi ma presentano piccole differenze rispetto a quello lineare. Gli elementi dell'insieme \textbf{P} e i descrittori dell'insieme \textbf{R} presentano un ulteriore elemento ed è l'array dei token visti. Infatti l'esecuzione di ogni descrittore deve avere i propri token visti e di conseguenza ogni elemento \textbf{P} che viene richiamato dal nodo padre \textit{u} del GSS che va ad aggiungersi all'insieme \textbf{R} devono avere il proprio array di token visti.  Alle funzioni \textit{add()} e \textit{pop()} è stato aggiunto un parametro in input per richiedere l'inserimento dell'array dei token visti. Nel metodo \textit{main} viene istanziato l'oggetto \textit{inputDataset}, di tipo InputDataset, e viene chiamato il metodo \textit{loadDataset()} per caricare l'input nella matrice, poi viene chiamato il metodo \textit{parse()} per iniziare il parsing ed a questo metodo viene passato come parametro \textit{inputdataset}. Il metodo \textit{parse()} è stato implementato seguendo le stesse regole usate per quello lineare ma con delle differenze che sono mostrate qui di seguito.
\begin{lstlisting}
public static String parse(InputDataset ds) {
	//...
	
	// (.>E>)
	case "L90":
		i = ds.getNextToken(i, ">", tokenViews);
		etichetta = "L10";
		break;
	// F.<hbar<T
	case "L6":
		i = ds.getNextToken(i, "<", tokenViews);
		etichetta = "L50";
		break;
	// F<.hbar<T
	case "L50":
		if (ds.getToken(i).equals("hbar")) {
			ds.setTokenFound(i, tokenViews);
			
			//...
			
			etichetta = "L7";
		} 
		else {
			etichetta = "L0";
		}
		break;
	
	//...
}
\end{lstlisting}
Le linee 1-10 mostrano come il modo in cui il parser gestisce gli operatori spaziali. Si può notare che vengono gestiti come item all'interno del corpo della produzione, e ogni volta che lo incontra viene chiamato il metodo \textit{getNextToken()} che prende in input un operatore spaziale, l'utimo token letto e l'array dei token visti. Questo metodo restituisce il token successivo da leggere; dopodichè si passa all'item successivo. In corrispondenza della lettura di un input (linee 15-28) viene verificata l'uguaglianza del token che si sta leggendo, se è vera il token letto viene messo nell'array dei token visti.
\section{GLL Parsing sui diagrammi di flusso}
Ora illustreremo un altro esempio di implementazione del GLL Parsing su un'altra grammatica posizionale. La grammatica posizionale seguente definisce i diagrammi di flusso.\par
\begin{center}
	\textit{Program $\to$ START link(1,1) Statements link(2,1) END} \par
	\textit{Statements $\to$ Statement link(2,1) Statements $\{$$\$\$$.1=$\$$1.1; $\$\$$.2=$\$$2.2;$\}$} \par
	\textit{Statements $\to$ Statement $\{$$\$\$$.1=$\$$1.1; $\$\$$.2=$\$$1.2;$\}$}\par
	\textit{Statement $\to$ INSTRUCTION $\{$$\$\$$.1=$\$$1.1; $\$\$$.2=$\$$1.2;$\}$}\par
	\textit{Statement $\to$ PREDICATE link(2,1) $\wedge$ link(3,2) Statements $\{$$\$\$$.1=$\$$1.1; $\$\$$.2=$\$$2.2;$\}$}\par
	\textit{Statement $\to$ PREDICATE  link(2,1) $\wedge$ link(1,2) Statements $\{$$\$\$$.1=$\$$1.1; $\$\$$.2=$\$$1.3;$\}$}\par
	\textit{Statement $\to$ PREDICATE  link(2,1) $\wedge$ nolink(1,2) Statements link(3,1)(-1) $\wedge$ link(2,2) Statements $\{$$\$\$$.1=$\$$1.1; $\$\$$.2=$\$$2.2;$\}$}\par
\end{center}
In questa grammatica gli operatori spaziali sono rappresentati 
\subsection{Lettura e gestione dell'input}
\lstinputlisting{C:/Users/fabio/Documents/GitHub/gll-parsing/src/dataset/Token.java}
\lstinputlisting{C:/Users/fabio/Documents/GitHub/gll-parsing/src/dataset/Statement.java}
\lstinputlisting{C:/Users/fabio/Documents/GitHub/InH.java}
\subsection{La GLLParsingFlowChart}